extends ../layout

block append css
    link(rel='stylesheet', href='/stylesheets/section.css')

block content
    h1 RAYONS
    p
        a(href='/users/signout') Sign Out

    div#wishes
        wish-item(v-for="wish in selectedWishes" v-bind:wish="wish" v-on:new_current_wish="newCurrentWish")
        currentwish-item(v-bind:currentwish="currentWish" v-on:new_name="searchProducts(currentWish)")
        products-item(v-for="(product, productKey, productIndex) in currentWish.matchingProducts" v-if="productIndex < maxProducts" v-bind:maxProducts="maxProducts" v-bind:wish="currentWish" v-bind:productkey="productKey" v-bind:product="product" v-on:select_product="bindCurrentWishWithProduct")

    a(href='/wishlist') Revenir a la wishlist

block append script
    script.
        function getFirstSelectedWish(){
            //on parcours le tableau ordonné pour chercher si le wish est dans l'objet pSelectedWishes
            for(var i = 0; i < wishGroups.length; i++ ) {
                var wishGroup = wishGroups[i];
                var wishGroupLength = wishGroup.wishes?wishGroup.wishes.length:0;
                for(var j = 0; j < wishGroupLength; j++ ) {
                    var wish = wishGroup.wishes[j];
                    var selected = pSelectedWishes[wishGroup.id]?pSelectedWishes[wishGroup.id][wish.id]?true:false:false;
                    if( selected ) {
                        return wish;
                    }
                }
            }
        }
        function getCurrentWishEntity( pCurrentWish ){
            //si le wish courant existe et est dans le tableau de wish selectionné, alors on le renvoi. Dans les autres cas on renvoi le premier element selectionné.
            if ( pCurrentWish ) {
                var currentWishIsSelected = pSelectedWishes[pCurrentWish.group]?pSelectedWishes[pCurrentWish.group][pCurrentWish.wish]?true:false:false;
                if ( currentWishIsSelected ) {
                    for(var i = 0; i < wishGroups.length; i++ ) {
                        var wishGroup = wishGroups[i];
                        var wishGroupLength = wishGroup.wishes?wishGroup.wishes.length:0;
                        for(var j = 0; j < wishGroupLength; j++ ) {
                            var wish = wishGroup.wishes[j];
                            var selected = pSelectedWishes[wishGroup.id]?pSelectedWishes[wishGroup.id][wish.id]?true:false:false;
                            if( wish.groupId == pCurrentWish.groupId && wish.id == pCurrentWish.wish ) {
                                return wish;
                            }
                        }
                    }
                }
            }
            return getFirstSelectedWish();
        }

        //add some usefull fields for vuejs to watch them
        //productsPids(pour l'appel) et productsToMatch(pour la reponse) sont les listes des produits à chercher avec leur pid puis rattacher aux wishes
        //on change le champ product en objet pour qu'il comprenne les productsInfos et l'id
        var wishGroups = JSON.parse('#{ wishGroups }'.replace(/&quot;/g,'"'));
        var pSelectedWishes = JSON.parse('#{ pSelectedWishes }'.replace(/&quot;/g,'"'));
        var productsToMatch = [];
        var productsPids = [];
        var wishGroupsLength = wishGroups.length;
        for(var i = 0; i < wishGroupsLength; i++ ) {
            var wishGroup = wishGroups[i];
            var wishGroupLength = wishGroup.wishes?wishGroup.wishes.length:0;
            for(var j = 0; j < wishGroupLength; j++ ) {
                var wish = wishGroups[i].wishes[j];
                wish.product = {id:wish.product, infos:{}, quantity : 0};
                wish.matchingProducts = [];
                var selected = pSelectedWishes[wishGroup.id]?pSelectedWishes[wishGroup.id][wish.id]?true:false:false;
                if( selected && pSelectedWishes[wishGroup.id][wish.id].product && pSelectedWishes[wishGroup.id][wish.id].product.id) {
                    var productId = pSelectedWishes[wishGroup.id][wish.id].product.id;
                    productsToMatchAlreadyExist = productsToMatch.hasOwnProperty(productId);
                    if ( !productsToMatchAlreadyExist ) {
                        productsToMatch[productId] = [{ groupPosition:i, wishPosition:j }];
                    }else{
                        productsToMatch[productId].push({ groupPosition:i, wishPosition:j });
                    }
                    productsPids.push( productId );
                }
            }
        }
        $.ajax({
            type: 'GET',
            url : '/products/details/',
            data: { pids :JSON.stringify(productsPids)},
            complete: function(responseObject) {
                var retreivedProducts = responseObject.responseJSON;
                try {
                    for(var product in productsToMatch) {
                        var infos = retreivedProducts[product];
                        for(var wishIndex in productsToMatch[product]) {
                            var wish = productsToMatch[product][wishIndex];
                            wishGroups[wish.groupPosition].wishes[wish.wishPosition].product.infos = infos;
                        }
                    }
                    //- console.log(products);
                } catch (e) {
                    console.log('une erreur à la recuperation des details est survenue : ' +e)
                }
                
                 
                //- self.currentWish.products = products;
                //- self.maxProducts++;
            }
        });

        // pCurrentWish is partial current wish, it is an object with group id and wish id
        pCurrentWish = JSON.parse('#{ pCurrentWish }'.replace(/&quot;/g,'"'));
        var currentWish = getCurrentWishEntity( pCurrentWish );

        //maximum produits affiché sur la page
        var maxProducts = 20;
    script(src="/javascripts/section.js")